(* Generated by Frama-C WP *)

Goal typed_lemma_sum3.
Hint property,sum3.
Proof.
intros.
apply Zlt_lower_bound_ind with
(P:= fun k => L_sum t a i_1 k + L_sum t a i_2 i_1 = L_sum t a i_2 k)(z := i_1).
intros.
assert (h:(i_1 = x \/ i_1 < x)) by omega.
destruct h.
- rewrite H4.
  rewrite Q_sum1.
  rewrite Int.Unit_def_l.
  reflexivity.
  omega.
- replace x with ((x-1)+1) by omega.
  generalize (H2 (x-1)).
  intros.
  replace (x-1+1) with (1+(x-1)) by omega.
  rewrite <- Q_sum2.
  rewrite <- Q_sum2.
  rewrite <- H5.
  rewrite Z.add_assoc.
  reflexivity.
  all:try omega.
- assumption.
Qed.

Goal typed_lemma_sum_4.
Hint property,sum_4.
Proof.
intros i j M1 M2 t.
assert (h: i > j \/ i <= j) by omega.
destruct h.
- intros hyp.
  rewrite Q_sum1.
  rewrite Q_sum1.
  reflexivity.
  omega.
  omega.
- generalize H.
  apply Zlt_lower_bound_ind with
  (P:= fun j => (i <= j) -> (forall k_0 : int,
  k_0 < j -> i <= k_0->
  M1 .[shift_sint32 t k_0 ] =
  M2 .[shift_sint32 t k_0 ]) ->
  L_sum M1 t i j = L_sum M2 t i j)
  (z:=i).
  intros.
  assert (h:(i = x \/ i < x)) by omega.
  destruct h.
   * rewrite H4.
     rewrite Q_sum1.
     rewrite Q_sum1.
     reflexivity.
     omega.
     omega.
   * assert (h:(i = x \/ i < x)) by omega.
     destruct h.
     + rewrite H5.
       rewrite Q_sum1.
       rewrite Q_sum1.
       reflexivity.
       omega.
       omega.
     +  replace x with (1+(x-1)) by omega.
        rewrite <- Q_sum2.
        rewrite <- Q_sum2.
        rewrite  (H3 (x-1)).
        rewrite H0.
        reflexivity.
        all:auto with zarith.
  * assumption.
Qed.


